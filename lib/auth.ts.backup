import { supabase } from "./supabase";
import { HAS_FAKE_LOGIN, STORAGE_KEYS, API_ENDPOINTS } from "./constants";
import { logger } from './logger'
import type { User } from "./types";

export type TelegramUser = {
  id: number;
  first_name: string;
  last_name?: string;
  username?: string;
  photo_url?: string;
  auth_date: number;
  hash: string;
};
  logger.debug('signInWithTelegram called', {
    id: telegramUser.id,
    username: telegramUser.username,
    first_name: telegramUser.first_name,
    HAS_FAKE_LOGIN,
    NODE_ENV: process.env.NODE_ENV,
    hasEnvEmail: !!process.env.NEXT_PUBLIC_DEV_EMAIL,
    hasEnvPassword: !!process.env.NEXT_PUBLIC_DEV_PASSWORD
  })

  // AGGRESSIVE PRODUCTION BYPASS: Skip all Supabase auth calls in production
  const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL_ENV === 'production' || window.location.hostname !== 'localhost'

  logger.info('üîç Environment detection', {
    NODE_ENV: process.env.NODE_ENV,
    VERCEL_ENV: process.env.VERCEL_ENV,
    hostname: window.location.hostname,
    isProduction
  })

  if (isProduction) {
    logger.info('üö® AGGRESSIVE PRODUCTION BYPASS: Skipping all Supabase auth calls')

    try {
      // Call backend to get JWT (this part works)
      const res = await fetch(API_ENDPOINTS.TELEGRAM_LOGIN, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(telegramUser),
      });

      if (!res.ok) {
        const errorText = await res.text();
        logger.error('Telegram login failed', { status: res.status, errorText });
        throw new Error("Telegram login failed");
      }

      const { access_token, refresh_token } = await res.json();

      // Store tokens directly
      localStorage.setItem("sb-access-token", access_token);
      localStorage.setItem("sb-refresh-token", refresh_token);

      logger.info('üö® PRODUCTION BYPASS: Tokens stored, skipping setSession (causes hanging)')

      // Mark that we completed login successfully (prevents reload loops)
      localStorage.setItem("telegram-login-complete", "true")

      // Try to get the real user profile using the stored JWT
      try {
        logger.info('üö® PRODUCTION BYPASS: Attempting to fetch real user profile')

        // Parse JWT to get user ID
        const payload = JSON.parse(atob(access_token.split('.')[1]));
        const userId = payload.sub;

        // Make direct API call to get user profile using the JWT
        const profileResponse = await fetch(`${process.env.NEXT_PUBLIC_SUPABASE_URL}/rest/v1/profiles?select=*&id=eq.${userId}`, {
          headers: {
            'Authorization': `Bearer ${access_token}`,
            'apikey': process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
            'Content-Type': 'application/json'
          }
        });

        if (profileResponse.ok) {
          const profiles = await profileResponse.json();
          if (profiles && profiles.length > 0) {
            const profile = profiles[0];
            const realUser: User = {
              id: profile.id,
              name: `${profile.first_name ?? ""} ${profile.last_name ?? ""}`.trim(),
              username: profile.username ?? "",
              avatar: profile.avatar_url ?? "",
              telegram_id: profile.telegram_id,
              first_name: profile.first_name,
              last_name: profile.last_name,
              bio: profile.bio,
              location: profile.location,
              website: profile.website,
              joined_at: profile.created_at
            };

            logger.info('üö® PRODUCTION BYPASS: Successfully fetched real user profile')
            return realUser;
          }
        }
      } catch (profileError) {
        logger.warn('üö® PRODUCTION BYPASS: Failed to fetch real profile, will reload page:', profileError);
      }

      // If we couldn't get the real profile, trigger a page reload
      // This ensures the auth hook can properly load the user
      logger.info('üö® PRODUCTION BYPASS: Could not fetch profile, forcing reload for proper auth flow')
      setTimeout(() => {
        window.location.reload()
      }, 500);

      // Return a minimal placeholder that won't be used (page will reload)
      return {
        id: `loading-${Date.now()}`,
        name: "Loading...",
        username: "loading",
        avatar: "",
        telegram_id: telegramUser.id,
        first_name: telegramUser.first_name || 'Loading',
        last_name: telegramUser.last_name || '',
        bio: undefined,
        location: undefined,
        website: undefined,
        joined_at: new Date().toISOString()
      } as User

    } catch (error) {
      logger.error('üö® PRODUCTION BYPASS ERROR:', error)
      throw error
    }
  }

  // Local dev override - use proper Supabase authentication
  if (HAS_FAKE_LOGIN) {
    logger.info('Using fake login for development')
    // For local development, sign in with a test email/password
    // This creates a real Supabase session with proper auth.uid()
    const testEmail = process.env.NEXT_PUBLIC_DEV_EMAIL;
    const testPassword = process.env.NEXT_PUBLIC_DEV_PASSWORD;

    if (!testEmail || !testPassword) {
      throw new Error("Local dev credentials not found. Please set NEXT_PUBLIC_DEV_EMAIL and NEXT_PUBLIC_DEV_PASSWORD in .env.local");
    }

    // Try to sign in with existing test user
    let { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: testEmail,
      password: testPassword,
    });

    // If user doesn't exist, create them
    if (authError && authError.message.includes("Invalid login credentials")) {
      logger.info("Creating test user for local development...");
      const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
        email: testEmail,
        password: testPassword,
      });

      if (signUpError || !signUpData.user || !signUpData.session) {
        throw new Error(`Failed to create test user: ${signUpError?.message}`);
      }

      // Use the sign up data directly
      authData = {
        user: signUpData.user,
        session: signUpData.session
      };
      authError = null;
    }

    if (authError || !authData?.user) {
      throw new Error(`Local dev auth failed: ${authError?.message}`);
    }

    const authUserId = authData.user.id;

    // Get or create profile for the authenticated user
    let { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("id, username, first_name, last_name, avatar_url")
      .eq("id", authUserId)
      .single();

    if (profileError && profileError.code === 'PGRST116') {
      // Profile doesn't exist, create it
      const { data: newProfile, error: createError } = await supabase
        .from("profiles")
        .insert({
          id: authUserId,
          username: "localdev",
          first_name: "Local",
          last_name: "Developer",
        })
        .select()
        .single();

      if (createError || !newProfile) {
        throw new Error(`Failed to create profile: ${createError?.message}`);
      }
      profile = newProfile;
    } else if (profileError || !profile) {
      throw new Error(`Profile error: ${profileError?.message || 'Profile not found'}`);
    }

    return {
      id: profile!.id,
      name: `${profile!.first_name ?? ""} ${profile!.last_name ?? ""}`.trim(),
      username: profile!.username ?? "",
      avatar: profile!.avatar_url ?? "",
      first_name: profile!.first_name,
      last_name: profile!.last_name,
    };
  }

  logger.info('Using real Telegram authentication')
  // Call backend to get JWT
  const res = await fetch(API_ENDPOINTS.TELEGRAM_LOGIN, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(telegramUser),
  });
  if (!res.ok) {
    const errorText = await res.text();
    logger.error('Telegram login failed', { status: res.status, errorText });
    throw new Error("Telegram login failed");
  }

  logger.debug('Response OK, parsing JSON...')
  const { access_token, refresh_token } = await res.json();
  logger.debug('JSON parsed successfully')

  logger.debug('Setting session...')

  // Store JWT in localStorage for potential future use
  localStorage.setItem("sb-access-token", access_token);

  logger.debug('Calling supabase.auth.setSession...')

  // Add timeout wrapper to prevent hanging (development only)
  const setSessionPromise = supabase.auth.setSession({
    access_token,
    refresh_token
  });

  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('setSession timeout after 10 seconds')), 10000);
  });

  const { data: sessionData, error: sessionError } = await Promise.race([
    setSessionPromise,
    timeoutPromise
  ]);

  logger.debug('setSession completed', {
    hasSessionData: !!sessionData,
    hasError: !!sessionError,
    errorMessage: sessionError?.message
  })

  if (sessionError) {
    logger.error('Session error:', sessionError);
    throw new Error("Failed to set session");
  }

  // Get user from JWT
  const { data: userData, error: userError } = await supabase.auth.getUser();
  if (userError || !userData?.user) {
    logger.error('No authenticated user after setting session:', userError);
    throw new Error("No authenticated user found after setting JWT");
  }
  const user = userData.user;

  logger.debug('Got user from session:', {
    id: user.id,
    email: user.email,
    userMetadata: user.user_metadata,
    appMetadata: user.app_metadata
  })

  // Upsert profile info
  logger.debug('Upserting profile with data:', {
    id: user.id,
    username: telegramUser.username || `user_${telegramUser.id}`,
    first_name: telegramUser.first_name,
    last_name: telegramUser.last_name,
    avatar_url: telegramUser.photo_url
  })

  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .upsert({
      id: user.id,
      username: telegramUser.username || `user_${telegramUser.id}`,
      first_name: telegramUser.first_name,
      last_name: telegramUser.last_name,
      avatar_url: telegramUser.photo_url,
      updated_at: new Date().toISOString(),
    })
    .select()
    .single();

  if (profileError || !profile) {
    logger.error('Profile upsert failed:', profileError);
    throw new Error("Failed to update profile");
  }

  logger.debug('Profile upserted successfully:', profile)

  return {
    id: profile.id,
    name: `${profile.first_name ?? ""} ${profile.last_name ?? ""}`.trim(),
    username: profile.username ?? "",
    avatar: profile.avatar_url ?? "",
    telegram_id: profile.telegram_id,
    first_name: profile.first_name,
    last_name: profile.last_name,
    bio: profile.bio,
    location: profile.location,
    website: profile.website,
    joined_at: profile.created_at
  };
}

export async function signOut(): Promise<void> {
  logger.info('üö™ signOut: Starting signOut process...')

  // Clear localStorage tokens first
  logger.debug('üö™ signOut: Clearing localStorage tokens...')
  localStorage.removeItem("sb-access-token");
  localStorage.removeItem("sb-refresh-token");
  localStorage.removeItem("telegram-login-complete");
  localStorage.removeItem("logout-in-progress"); // Clear logout flag

  // PRODUCTION BYPASS: Skip supabase.auth.signOut in production
  const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL_ENV === 'production' || window.location.hostname !== 'localhost'

  if (isProduction) {
    logger.info('üö® PRODUCTION BYPASS: Skipping supabase.auth.signOut()')
    // Clear all our custom localStorage items
    localStorage.removeItem("sb-user");
    localStorage.removeItem("sb-access-token");
    localStorage.removeItem("sb-refresh-token");

    // Force page reload to clear state
    setTimeout(() => {
      window.location.reload()
    }, 100)
    return;
  }

  // BYPASS: Skip supabase.auth.signOut due to hanging issues
  // Apply same bypass as getSession - Supabase auth calls are unreliable
  logger.info('ÔøΩ BYPASS: Skipping supabase.auth.signOut() due to hanging issues (both prod and dev)')

  // Clear all our custom localStorage items
  localStorage.removeItem("sb-user");
  localStorage.removeItem("sb-access-token");
  localStorage.removeItem("sb-refresh-token");

  // Also clear any Supabase-managed localStorage items
  const keys = Object.keys(localStorage);
  keys.forEach(key => {
    if (key.startsWith('supabase.') || key.startsWith('sb-')) {
      localStorage.removeItem(key);
    }
  });

  // Since we're bypassing supabase.auth.signOut(), manually trigger auth state reset
  // by dispatching a storage event that the auth system can listen to
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('manual-signout', { detail: { timestamp: Date.now() } }));
  }

  logger.debug('üö™ signOut: Manual signout completed successfully')
}

// Token validation and utilities
export async function getCurrentUserToken(): Promise<string | null> {
  const timestamp = new Date().toISOString()
  logger.info(`üîç [${timestamp}] getCurrentUserToken: Starting token retrieval`)

  try {
    // In production, read from localStorage directly
    const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL_ENV === 'production' || window.location.hostname !== 'localhost'
    logger.debug(`üîç [${timestamp}] getCurrentUserToken: Environment check - isProduction: ${isProduction}`)

    if (isProduction) {
      const token = localStorage.getItem("sb-access-token");
      logger.info(`üîç [${timestamp}] getCurrentUserToken: PRODUCTION BYPASS - token found: ${!!token}`)
      if (token) {
        logger.debug('üö® PRODUCTION BYPASS: Found token in localStorage')
        return token;
      }
      logger.debug('üö® PRODUCTION BYPASS: No token found in localStorage')
      return null;
    }

    // Development: Use proper Supabase session
    logger.info(`üîç [${timestamp}] getCurrentUserToken: DEVELOPMENT - calling supabase.auth.getSession()`)
    const sessionStartTime = Date.now()

    const { data, error } = await supabase.auth.getSession();
    const sessionEndTime = Date.now()
    const sessionDuration = sessionEndTime - sessionStartTime

    logger.info(`üîç [${timestamp}] getCurrentUserToken: getSession completed in ${sessionDuration}ms`)

    if (error) {
      logger.error(`üîç [${timestamp}] getCurrentUserToken: Error getting current session:`, error);
      return null;
    }

    const token = data.session?.access_token;
    logger.info(`üîç [${timestamp}] getCurrentUserToken: Session result - hasSession: ${!!data.session}, hasToken: ${!!token}`)
    logger.debug('getCurrentUserToken result:', { hasToken: !!token });
    return token || null;
  } catch (error) {
    logger.error(`üîç [${timestamp}] getCurrentUserToken: EXCEPTION caught:`, error);
    return null;
  }
}

export async function getCurrentUser(): Promise<User | null> {
  logger.debug('getCurrentUser called')

  try {
    // In production, bypass Supabase and use localStorage
    const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL_ENV === 'production' || window.location.hostname !== 'localhost'

    if (isProduction) {
      logger.info('üö® PRODUCTION BYPASS: getCurrentUser bypassing Supabase')

      // Check if we have stored tokens
      const hasToken = localStorage.getItem("sb-access-token");
      if (!hasToken) {
        logger.debug('üö® PRODUCTION BYPASS: No access token found')
        return null;
      }

      // Check if we have cached user data
      const cachedUser = localStorage.getItem("sb-user");
      if (cachedUser) {
        try {
          const user = JSON.parse(cachedUser);
          logger.debug('üö® PRODUCTION BYPASS: Returning cached user')
          return user;
        } catch (e) {
          logger.debug('üö® PRODUCTION BYPASS: Failed to parse cached user')
        }
      }

      logger.debug('üö® PRODUCTION BYPASS: No cached user, returning null (auth hook will handle)')
      return null;
    }

    // Development: Use proper Supabase authentication
    const { data: userData, error: userError } = await supabase.auth.getUser();
    if (userError || !userData?.user) {
      logger.debug('No authenticated user:', userError?.message);
      return null;
    }

    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("*")
      .eq("id", userData.user.id)
      .single();

    if (profileError || !profile) {
      logger.error('Profile fetch failed:', profileError);
      return null;
    }

    const user: User = {
      id: profile.id,
      name: `${profile.first_name ?? ""} ${profile.last_name ?? ""}`.trim(),
      username: profile.username ?? "",
      avatar: profile.avatar_url ?? "",
      telegram_id: profile.telegram_id,
      first_name: profile.first_name,
      last_name: profile.last_name,
      bio: profile.bio,
      location: profile.location,
      website: profile.website,
      joined_at: profile.created_at
    };

    logger.debug('getCurrentUser success:', { userId: user.id, username: user.username });
    return user;
  } catch (error) {
    logger.error('getCurrentUser error:', error);
    return null;
  }
}

export async function refreshAuthSession(): Promise<void> {
  logger.debug('refreshAuthSession called');

  const isProduction = process.env.NODE_ENV === 'production' || process.env.VERCEL_ENV === 'production' || window.location.hostname !== 'localhost'

  if (isProduction) {
    logger.info('üö® PRODUCTION BYPASS: Skipping session refresh')
    return;
  }

  // Development: Use proper Supabase session refresh
  try {
    const { data, error } = await supabase.auth.refreshSession();
    if (error) {
      logger.error('Session refresh failed:', error);
      // Don't throw - let the app handle auth state naturally
      return;
    }
    logger.debug('Session refreshed successfully');
  } catch (error) {
    logger.error('refreshAuthSession error:', error);
  }
}

export async function handleAuthError(error: any): Promise<boolean> {
  logger.debug('handleAuthError called', { error });

  // Check if this is an auth-related error
  if (
    error?.status === 403 ||
    error?.message?.includes('JWT') ||
    error?.message?.includes('token') ||
    error?.message?.includes('unauthorized') ||
    error?.message?.includes('Unauthorized')
  ) {
    logger.info('üîß Auth error detected, attempting recovery');

    try {
      // Try to refresh the session first
      await refreshAuthSession();

      // If that doesn't work, force a page reload
      setTimeout(() => {
        window.location.reload();
      }, 1000);

      return true; // Indicate we handled the error
    } catch (refreshError) {
      logger.error('Auth recovery failed:', refreshError);
      // Force reload as last resort
      setTimeout(() => {
        window.location.reload();
      }, 1000);
      return true;
    }
  }

  return false; // Not an auth error
}

export async function validateAuthState(): Promise<boolean> {
  logger.debug('validateAuthState called');

  try {
    const token = await getCurrentUserToken();
    const user = await getCurrentUser();

    const isValid = !!(token && user);
    logger.debug('Auth state validation:', { hasToken: !!token, hasUser: !!user, isValid });

    return isValid;
  } catch (error) {
    logger.error('validateAuthState error:', error);
    return false;
  }
}
